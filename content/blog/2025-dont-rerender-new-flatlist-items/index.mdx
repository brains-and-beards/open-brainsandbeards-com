---
path: '/blog/2025-dont-rerender-new-flatlist-items'
date: '2025-03-13T13:00:00.000Z'
title: 'FlatList Optimization: Avoid Re-Rendering When Adding or Removing Items'
image: header.jpg
author: Szymon Koper
---

#### Introduction  

This post is a follow-up to **[Don't Re-Render All FlatList Items](/blog/2022-dont-rerender-all-flatlist-items)**. In the previous article, we optimized FlatList to prevent unnecessary re-renders when **updating list item values**. This time, we’ll tackle another common issue: **avoiding re-renders when adding or removing items**.  

Many developers believe they need to **wrap every FlatList prop in `useCallback` or `useMemo`** to optimize performance. But is that really necessary? Let’s find out.  

This issue is especially common in **apps with infinite scrolling or pagination**, where new items are fetched and added to a list dynamically. If your app uses `onEndReached` in `FlatList` to fetch new pages from an API, the same principles apply.

---

### **The Problem: Every Item Re-Renders When Adding a New One**  

Imagine an app that fetches data from the internet and **appends new items** to a FlatList. Here’s what should happen:  

✅ **New items should render** when added.  
❌ **Existing items should not re-render** (since they haven’t changed).  

But in many cases, **all items re-render when a new one is added!**  

#### **Let's See It in Action**  

<div class="gif-container">

![Recording of the example app - adding and deleting items](flatlist-app-demo.gif)

This is the example app where items are added and removed.

</div>

Here’s an Expo Snack where **all items re-render** when we add a new one:  

👉 **[Try the Snack Here](https://snack.expo.dev/@sakydpozrux/rerender-only-changed-items)** (You'll edit it yourself later!)  

**How to test:**  
1. Open the **console logs** in your browser.  
2. Click "Add Item" and watch the logs.  
3. Notice that **every existing item re-renders, even though they haven’t changed!**  

<div class="gif-container">

![Logs before optimization - too many re-renders](flatlist-logs-before.gif)

Here’s what happens in the console when adding items in the unoptimized version.

</div>

**Example console output:**
```
Rendering item: 1
Rendering item: 2
Rendering item: 1  <- Why is this rendering again?
Rendering item: 2
Rendering item: 3  <- Only this should be new
Rendering item: 1
Rendering item: 2
Rendering item: 3
```

---

### **The Fix: Just Add `React.memo`**  

Here’s the best part: the **fix is incredibly simple**.  

**✅ Wrap `ListItem` in `React.memo`. That’s it.**  

Now, `ListItem` will **only re-render when its props change**. Since each item’s `id` remains the same, old items won’t re-render when new ones are added.  

#### **Console Output After the Fix:**  
```
Rendering item: 1
Rendering item: 2
Rendering item: 3  <- Only new items render now!
```

<div class="gif-container">

![Logs after optimization - only new items render](flatlist-logs-after.gif)

After the fix, only new items render as expected.

</div>

**Boom! No more unnecessary re-renders. 🎉**  

---

### **When `useCallback` Becomes Necessary**  

In most cases, re-creating the `renderItem` function inside `FlatList` doesn’t cause re-renders. But there are situations where **wrapping it in `useCallback` is necessary**.  

Let’s modify the example by adding a **timer** at the top of the screen that updates every second, showing the current time (`hh:mm:ss`). This change will cause **the entire component to re-render every second**—which will **also re-render every FlatList item** unnecessarily.  

#### **Updated Example: Now With a Timer**  
```tsx
const [time, setTime] = React.useState(new Date().toLocaleTimeString());
React.useEffect(() => {
  const interval = setInterval(() => {
    setTime(new Date().toLocaleTimeString());
  }, 1000);
  return () => clearInterval(interval);
}, []);
```

🚨 **All items re-render every second!** 🚨  

This happens because **the parent component is re-rendering**, which causes `FlatList` to receive a **new function reference for `renderItem` on each render**. Since `FlatList` sees a new function, it **re-renders all items**.  

#### **The Fix: Wrapping Callbacks in `useCallback`**  

To fix this, we need to **wrap `renderItem` and `keyExtractor` in `useCallback`**. This ensures the function **stays the same across renders**, preventing unnecessary re-renders.  

```tsx
keyExtractor={React.useCallback((id) => id, [])}
renderItem={React.useCallback(({ item: id }) => <ListItem id={id} />, [])}
```

Alternatively, we can **define them outside the component function** or **omit `keyExtractor`**, since `id => id` is the default behavior.  

---

### **Better Architecture: Extracting `Clock` Component**  

A better approach is to **extract the clock into its own component**. This keeps **state updates isolated**, preventing unnecessary re-renders.  

```tsx
const Clock = () => {
  const [time, setTime] = React.useState(new Date().toLocaleTimeString());
  React.useEffect(() => {
    const interval = setInterval(() => {
      setTime(new Date().toLocaleTimeString());
    }, 1000);
    return () => clearInterval(interval);
  }, []);
  return <Text style={{ fontSize: 18, fontWeight: "bold" }}>Current time: {time}</Text>;
};
```

By using `<Clock />` inside `ListScreen`, only the clock updates, **keeping FlatList untouched**. This is a **better architectural choice** because:  
✅ It isolates responsibilities (the clock only manages time).  
✅ It prevents unnecessary re-renders in unrelated components.  
✅ It makes the code cleaner and more maintainable.  

---

### **FlashList Handles This Differently**  

If you’re using `FlashList` instead of `FlatList`, be aware that **FlashList has its own optimizations for re-renders**. Some of the techniques used here **may not be necessary with FlashList** because it already handles updates differently.  

We won’t cover FlashList in this post, but it’s worth exploring in the future. Let me know if you’d like a separate post about it!  

---

👉 **What’s next?**  
- If you missed it, check out **[Part 1: Don't Re-Render All FlatList Items](/blog/2022-dont-rerender-all-flatlist-items/)**.  
- Let me know in the comments if you’ve encountered similar performance issues in your apps!  